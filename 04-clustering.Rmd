---
title: "Clustering"
author: Data Lab for ALSF
date: 2021
output:
  html_notebook: 
    toc: true
    toc_float: true
---

This notebook will begin looking at clustering methods on the expression of the genes in a single sample of the dataset of interest, from an unbiased approach.

## Set Up 

```{r}
# Load libraries
library(magrittr)
library(scater)
library(readr)
library(bluster)
library(ggpubr)
library(pheatmap)

# Set file paths
data_dir <- file.path("results", "Gawad_processed_data")
```

## Custom functions

```{r}
perform_clustering <- function(normalized_sce, k, cluster_name, check_stability = FALSE, seed = 2021) {
    # Purpose: Perform the k-means clustering on a normalized SingleCellExperiment object
    
    # set the seed for reproducible results
    set.seed(seed)
    
    # extract the principal components matrix
    pca_matrix <- reducedDim(normalized_sce, "PCA")
    
    if (startsWith(cluster_name, "kcluster")) {
      # perform k-means clustering
      clusters <- clusterRows(pca_matrix, KmeansParam(centers = k))
    } else if (startsWith(cluster_name, "walktrap_cluster")) {
      clusters <- clusterRows(pca_matrix, NNGraphParam(k = k,
                                                       cluster.fun = "walktrap"))
    } else if (startsWith(cluster_name, "louvain_cluster")) {
      clusters <- clusterRows(pca_matrix,
                              NNGraphParam(
                                k = k,
                                type = "jaccard",
                                cluster.fun = "louvain"
                              ))
    }
    
    # store cluster results in the SCE object
    normalized_sce[[cluster_name]] <- factor(clusters)
    
    # check cluster stability if the `check_stability == TRUE`
    if (check_stability) {
      if (startsWith(cluster_name, "kcluster")) {
        # Create subfunctions for `bootstrapStability()`
        cluster_stability_subfunction <- function(x) {
          clusterRows(x, KmeansParam(centers = k))
        }
      } else if (startsWith(cluster_name, "walktrap_cluster")) {
        cluster_stability_subfunction <- function(x) {
          clusterRows(x, NNGraphParam(k = k, cluster.fun = "walktrap"))
        }
      } else if (startsWith(cluster_name, "louvain_cluster")) {
        cluster_stability_subfunction <- function(x) {
          clusterRows(x,
                      NNGraphParam(
                        k = k,
                        type = "jaccard",
                        cluster.fun = "louvain"
                      ))
        }
      }
      
      # create name for the bootstrapping results to be stored in
      bootstrapping_name <-
        paste("bootstrapping_results", cluster_name, sep = "_")
      
      # run the `bootstapStability()` function
      metadata(normalized_sce)[[bootstrapping_name]] <-
        bootstrapStability(pca_matrix,
                           FUN = cluster_stability_subfunction,
                           clusters = normalized_sce[[cluster_name]])
      
    }
    
    return(normalized_sce)
    
  }

cluster_validity_stats <- function(clustered_sce, cluster_name) {
  # Purpose: Check the cluster purity of the clusters in the clustered SingleCellExperiment object
  
  # isolate the clusters stored in the `cluster_name` slot of the SCE object
  clusters <- clustered_sce[[(cluster_name)]]
  
  # use `neighborPurity` to check the purity of clusters
  purity_df <-
    neighborPurity(reducedDim(clustered_sce, "PCA"), clusters = clusters) %>% 
    as.data.frame() %>%
    tibble::rownames_to_column("cell_barcode")
  purity_df$maximum <- factor(purity_df$maximum)
  
  # use `approxSilhouette()` to approximate silhouettes
  sil_df <- approxSilhouette(reducedDim(clustered_sce, "PCA"),
                                 clusters = clusters) %>%
    as.data.frame() %>%
    tibble::rownames_to_column("cell_barcode")
  
  # account for negative widths
  sil_df$closest <-
    factor(ifelse(sil_df$width > 0, clusters, sil_df$other))
  
  cluster_stats_df <- purity_df %>%
    dplyr::left_join(sil_df) %>%
    dplyr::mutate(cluster = factor(clusters))
  
  return(cluster_stats_df)
}

plot_clustering_validity <- function(cluster_validity_df, measure, colour_var, facet_var) {
  # Purpose: Plot `kmeans` clustering data frame
  
  # convert into symbols for plotting
  measure <- rlang::sym(measure)
  colour_var <- rlang::sym(colour_var)
  facet_var <- rlang::sym(facet_var)
  
  # plot the cluster validity data frames
  ggplot(cluster_validity_df, aes(x = cluster, y = !!measure, colour = !!colour_var)) +
    ggbeeswarm::geom_quasirandom(method = "smiley") +
    facet_wrap(facet_var, ncol = 1)
}

plot_cluster_stability <- function(normalized_sce, cluster_name) {
  # Purpose: Plot the cluster bootstrapping stability values of the clusters
  # stored in the SingleCellExperiment object
  
  # set the name from which the bootstrapping results can be retrieved from the SCE object
  bootstrapping_name <- paste("bootstrapping_results", cluster_name, sep = "_")
  
  # plot cluster stability
  stability_pheatmap <- pheatmap(
    metadata(normalized_sce)[[bootstrapping_name]],
    cluster_row = FALSE,
    cluster_col = FALSE,
    color = viridis::magma(100),
    breaks = seq(-1, 1, length.out = 101),
    main = cluster_name
  )
}
```

## Read in data

```{r}
sample_290_normalized <- read_rds(
  file.path(data_dir, "SCPCS000216", "SCPCL000290_miQC_downstream_processed_normalized_reduced_sce.rds"))
```

## Perform clustering

### k-means

```{r}
# Perform k-means clustering
for (i in 2:5) {
  cluster_name <- paste("kcluster", i, sep = "")
  sample_290_normalized <- perform_clustering(sample_290_normalized,
                     k = i,
                     cluster_name = cluster_name,
                     check_stability = TRUE)
}
kmeans_cluster_names <- c("kcluster2", "kcluster3", "kcluster4", "kcluster5")

# Plot k-means
kmeans_cluster_names %>%
   purrr::map(~ plotReducedDim(sample_290_normalized, dimred = "PCA", colour_by = .x))
```

### graph-based, walktrap

```{r}
# Perform graph-based walktrap clustering
for (i in 12:14) {
  cluster_name <- paste("walktrap_cluster", i, sep = "")
  sample_290_normalized <- perform_clustering(sample_290_normalized,
                     k = i,
                     cluster_name = cluster_name,
                     check_stability = TRUE)
}
walktrap_cluster_names <- c("walktrap_cluster12", "walktrap_cluster13", "walktrap_cluster14")

# Plot
walktrap_cluster_names %>%
   purrr::map(~ plotReducedDim(sample_290_normalized, dimred = "PCA", colour_by = .x))
```

### graph-based, louvain

```{r}
# Perform graph-based louvain clustering
for (i in 12:14) {
  cluster_name <- paste("louvain_cluster", i, sep = "")
  sample_290_normalized <- perform_clustering(sample_290_normalized,
                     k = i,
                     cluster_name = cluster_name,
                     check_stability = TRUE)
}
louvain_cluster_names <- c("louvain_cluster12", "louvain_cluster13", "louvain_cluster14")

# Plot
louvain_cluster_names %>%
   purrr::map(~ plotReducedDim(sample_290_normalized, dimred = "PCA", colour_by = .x))
```

## Check cluster validity stats

### k-means

```{r}
# Check the k-means cluster validity stats
kmeans_cluster_validity_df_list <- kmeans_cluster_names %>%
  purrr::map(~ cluster_validity_stats(sample_290_normalized, .x))
names(kmeans_cluster_validity_df_list) <- kmeans_cluster_names
kmeans_cluster_validity_df <- dplyr::bind_rows(kmeans_cluster_validity_df_list,
                                       .id = "kmeans_n")
# Plot the k-means cluster purity
plot_clustering_validity(kmeans_cluster_validity_df, "purity", "maximum", "kmeans_n")
# Plot k-means cluster silhouette
plot_clustering_validity(kmeans_cluster_validity_df, "width", "closest", "kmeans_n")
```
### graph-based, walktrap

```{r}
# Check the walktrap cluster validity stats
walktrap_cluster_validity_df_list <- walktrap_cluster_names %>%
  purrr::map(~ cluster_validity_stats(sample_290_normalized, .x))
names(walktrap_cluster_validity_df_list) <- walktrap_cluster_names
walktrap_cluster_validity_df <- dplyr::bind_rows(walktrap_cluster_validity_df_list,
                                       .id = "walktrap_n")

# Plot the graph-based walktrap cluster purity
plot_clustering_validity(walktrap_cluster_validity_df, "purity", "maximum", "walktrap_n")
# Plot graph-based walktrap cluster silhouette
plot_clustering_validity(walktrap_cluster_validity_df, "width", "closest", "walktrap_n")
```
### graph-based, louvain

```{r}
# Check the louvain cluster validity stats
louvain_cluster_validity_df_list <- louvain_cluster_names %>%
  purrr::map(~ cluster_validity_stats(sample_290_normalized, .x))
names(louvain_cluster_validity_df_list) <- louvain_cluster_names
louvain_cluster_validity_df <- dplyr::bind_rows(louvain_cluster_validity_df_list,
                                       .id = "louvain_n")

# Plot the graph-based louvain cluster purity
plot_clustering_validity(louvain_cluster_validity_df, "purity", "maximum", "louvain_n")
# Plot graph-based louvain cluster silhouette
plot_clustering_validity(louvain_cluster_validity_df, "width", "closest", "louvain_n")
```

## Check cluster stability

### k-means

```{r}
# Check and plot cluster stability
kmeans_cluster_names %>%
  purrr::walk(~ plot_cluster_stability(sample_290_normalized, .x))
```

### graph-based, walktrap

```{r}
walktrap_cluster_names %>%
  purrr::walk(~ plot_cluster_stability(sample_290_normalized, .x))
```

### graph-based, louvain

```{r}
louvain_cluster_names %>%
  purrr::walk(~ plot_cluster_stability(sample_290_normalized, .x))
```

## Session info

```{r}
sessionInfo()
```
